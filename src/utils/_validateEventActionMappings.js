// src/utils/eventActionValidation.js
import { AUTH_ACTIONS, CAIXINHA_ACTIONS, CONNECTION_ACTIONS, INTERESTS_ACTIONS, 
  INVITATION_ACTIONS, MESSAGE_ACTIONS, NOTIFICATION_ACTIONS, USER_ACTIONS, 
  USER_PREFS_ACTIONS } from "../core/constants/actions";
import { AUTH_EVENTS, CAIXINHA_EVENTS, CONNECTION_EVENTS, INTERESTS_EVENTS, 
  INVITATION_EVENTS, MESSAGE_EVENTS, NOTIFICATION_EVENTS, USER_EVENTS, 
  USER_PREFS_EVENTS } from "../core/constants/events";
import { serviceLocator } from "../core/services/BaseService";
  
/**
 * Valida√ß√£o avan√ßada de mapeamentos evento-a√ß√£o
 * Sistema completo para diagn√≥stico, an√°lise e melhoria de mapeamentos
 */
export const validateEventActionMappings = (options = { 
  verbose: true, 
  includeSuggestions: true,
  includeImpactAnalysis: true
}) => {
  console.group('üîç Valida√ß√£o de Mapeamentos Evento-A√ß√£o');
  const eventActionBridgeService = serviceLocator.get('eventActionBridge')
  
  // Obter todos os tipos de eventos dispon√≠veis
  const allEventTypes = Object.values({
    
    ...AUTH_EVENTS,
    ...CONNECTION_EVENTS,
    ...MESSAGE_EVENTS,
    ...INVITATION_EVENTS,
    ...NOTIFICATION_EVENTS,
    ...INTERESTS_EVENTS,
    ...USER_EVENTS,
    ...CAIXINHA_EVENTS,
    ...USER_PREFS_EVENTS
  });
  
  // Obter todos os tipos de a√ß√µes dispon√≠veis
  const allActionTypes = Object.values({
    ...AUTH_ACTIONS,
    ...CONNECTION_ACTIONS,
    ...MESSAGE_ACTIONS,
    ...INVITATION_ACTIONS,
    ...NOTIFICATION_ACTIONS,
    ...INTERESTS_ACTIONS,
    ...USER_ACTIONS,
    ...CAIXINHA_ACTIONS,
    ...USER_PREFS_ACTIONS
  });
  
  // Mapear constantes para seus namespaces originais
  const eventToNamespaceMap = {};
  const actionToNamespaceMap = {};
  
  // Popular mapas para eventos
  Object.entries({
    AUTH_EVENTS, CONNECTION_EVENTS, MESSAGE_EVENTS, INVITATION_EVENTS,
    NOTIFICATION_EVENTS, INTERESTS_EVENTS, USER_EVENTS, CAIXINHA_EVENTS,
    USER_PREFS_EVENTS
  }).forEach(([namespaceName, namespace]) => {
    Object.values(namespace).forEach(value => {
      eventToNamespaceMap[value] = {
        namespace: namespaceName,
        constantName: Object.entries(namespace).find(([_, v]) => v === value)?.[0] || 'UNKNOWN'
      };
    });
  });
  
  // Popular mapas para a√ß√µes
  Object.entries({
    AUTH_ACTIONS, CONNECTION_ACTIONS, MESSAGE_ACTIONS, INVITATION_ACTIONS,
    NOTIFICATION_ACTIONS, INTERESTS_ACTIONS, USER_ACTIONS, CAIXINHA_ACTIONS,
    USER_PREFS_ACTIONS
  }).forEach(([namespaceName, namespace]) => {
    Object.values(namespace).forEach(value => {
      actionToNamespaceMap[value] = {
        namespace: namespaceName,
        constantName: Object.entries(namespace).find(([_, v]) => v === value)?.[0] || 'UNKNOWN'
      };
    });
  });
  
  // Extrair os mapeamentos atuais
  const mappedEvents = [...new Set(Array.from(eventActionBridgeService.mappings.values()).map(m => m.eventType))];
  const mappedActions = [...new Set(Array.from(eventActionBridgeService.mappings.values()).map(m => m.actionType))];
  
  // =========================================================================
  // Fun√ß√µes Utilit√°rias
  // =========================================================================
  
  // Extrair o servi√ßo de um tipo de evento
  const getServiceNameFromEvent = (eventType) => {
    const mapping = Array.from(eventActionBridgeService.mappings.values())
      .find(m => m.eventType === eventType);
    return mapping?.serviceName || eventType.split('_')[0].toLowerCase();
  };
  
  // Extrair o m√≥dulo de uma a√ß√£o
  const getModuleFromAction = (actionType) => {
    return actionType.split('/')[0];
  };
  
  // Obter nome constante do evento para c√≥digo
  const getEventConstantName = (eventType) => {
    const info = eventToNamespaceMap[eventType];
    return info ? `${info.namespace}.${info.constantName}` : `'${eventType}'`;
  };
  
  // Obter nome constante da a√ß√£o para c√≥digo
  const getActionConstantName = (actionType) => {
    const info = actionToNamespaceMap[actionType];
    return info ? `${info.namespace}.${info.constantName}` : `'${actionType}'`;
  };
  
  // Agrupar itens por m√≥dulo
  const groupByModule = (items) => {
    return items.reduce((acc, item) => {
      let module;
      
      if (item.includes('/')) {
        // A√ß√µes no formato "module/ACTION_TYPE"
        module = item.split('/')[0];
      } else {
        // Eventos, tentar determinar m√≥dulo a partir do nome
        const firstPart = item.split('_')[0].toLowerCase();
        
        // Mapeamento simples de prefixos para m√≥dulos
        const moduleMap = {
          'auth': 'auth',
          'users': 'users',
          'messages': 'messages',
          'notifications': 'notifications',
          'invitation': 'invites',
          'caixinhas': 'caixinhas',
          'connections': 'connections',
          'interests': 'interests',
          'pref': 'userPreferences'
        };
        
        module = moduleMap[firstPart] || 'outros';
      }
      
      if (!acc[module]) acc[module] = [];
      acc[module].push(item);
      return acc;
    }, {});
  };
  
  // Verificar similaridade entre strings (para sugest√µes)
  const stringSimilarity = (s1, s2) => {
    s1 = s1.toLowerCase();
    s2 = s2.toLowerCase();
    
    // Algoritmo de dist√¢ncia de Levenshtein simplificado
    if (s1.includes(s2) || s2.includes(s1)) return 0.8;
    
    const pairs1 = new Set();
    const pairs2 = new Set();
    
    for (let i = 0; i < s1.length - 1; i++) {
      pairs1.add(s1.substring(i, i + 2));
    }
    
    for (let i = 0; i < s2.length - 1; i++) {
      pairs2.add(s2.substring(i, i + 2));
    }
    
    const intersection = new Set([...pairs1].filter(x => pairs2.has(x)));
    const union = new Set([...pairs1, ...pairs2]);
    
    return intersection.size / union.size;
  };
  
  // Encontrar a√ß√£o sugerida para evento
  const findSuggestedAction = (eventType, unusedActions) => {
    // Extrair partes significativas do nome do evento
    const eventParts = eventType.split('_');
    const eventPrefix = eventParts[0].toLowerCase();
    const eventVerb = eventParts.length > 1 ? eventParts[1].toLowerCase() : '';
    
    // Tentar encontrar correspond√™ncia direta
    const modulePrefix = eventType.split('_')[0].toLowerCase();
    
    // Mapeamento de m√≥dulos
    const moduleMap = {
      'auth': 'auth',
      'users': 'users', 
      'messages': 'messages',
      'notifications': 'notifications',
      'invitation': 'invites',
      'caixinhas': 'caixinhas',
      'connections': 'connections',
      'interests': 'interests',
      'pref': 'userPreferences'
    };
    
    const moduleActions = unusedActions.filter(action => {
      const actionModule = action.split('/')[0];
      return actionModule === moduleMap[modulePrefix];
    });
    
    // Se encontramos a√ß√µes do mesmo m√≥dulo, procurar a mais similar
    if (moduleActions.length > 0) {
      const actionScores = moduleActions.map(action => {
        const actionType = action.split('/')[1] || '';
        const score = stringSimilarity(eventType, actionType);
        return { action, score };
      });
      
      // Ordenar por maior similaridade
      actionScores.sort((a, b) => b.score - a.score);
      
      // Retornar a a√ß√£o mais similar se a pontua√ß√£o for adequada
      if (actionScores[0].score > 0.3) {
        return actionScores[0].action;
      }
    }
    
    // Sem sugest√£o adequada
    return null;
  };
  
  // =========================================================================
  // Valida√ß√£o Principal
  // =========================================================================
  
  // Verificar eventos n√£o mapeados
  const unmappedEvents = allEventTypes.filter(e => !mappedEvents.includes(e));
  
  // Verificar a√ß√µes n√£o utilizadas
  const unusedActions = allActionTypes.filter(a => !mappedActions.includes(a));
  
  // Verificar mapeamentos multidirecionais
  const checkForOverlaps = () => {
    const eventToActions = new Map();
    const actionToEvents = new Map();
    
    eventActionBridgeService.mappings.forEach(mapping => {
      // Mapeamento evento ‚Üí a√ß√µes
      if (!eventToActions.has(mapping.eventType)) {
        eventToActions.set(mapping.eventType, []);
      }
      eventToActions.get(mapping.eventType).push(mapping.actionType);
      
      // Mapeamento a√ß√£o ‚Üí eventos
      if (!actionToEvents.has(mapping.actionType)) {
        actionToEvents.set(mapping.actionType, []);
      }
      actionToEvents.get(mapping.actionType).push(mapping.eventType);
    });
    
    // Encontrar eventos que disparam m√∫ltiplas a√ß√µes
    const eventsWithMultipleActions = [...eventToActions.entries()]
      .filter(([_, actions]) => actions.length > 1);
    
    // Encontrar a√ß√µes disparadas por m√∫ltiplos eventos
    const actionsWithMultipleEvents = [...actionToEvents.entries()]
      .filter(([_, events]) => events.length > 1);
    
    return {
      eventToActions,
      actionToEvents,
      eventsWithMultipleActions,
      actionsWithMultipleEvents
    };
  };
  
  // Verificar exist√™ncia
  const validateExistence = () => {
    const invalidEvents = mappedEvents.filter(
      event => !allEventTypes.includes(event)
    );
    
    const invalidActions = mappedActions.filter(
      action => !allActionTypes.includes(action)
    );
    
    return { invalidEvents, invalidActions };
  };
  
  // Executar verifica√ß√µes
  const { eventToActions, actionToEvents, eventsWithMultipleActions, actionsWithMultipleEvents } = checkForOverlaps();
  const { invalidEvents, invalidActions } = validateExistence();
  
  // Agrupar resultados por m√≥dulo
  const groupedUnmapped = groupByModule(unmappedEvents);
  const groupedUnused = groupByModule(unusedActions);
  const groupedMappedEvents = groupByModule(mappedEvents);
  const groupedMappedActions = groupByModule(mappedActions);
  
  // =========================================================================
  // Gera√ß√£o de Sugest√µes
  // =========================================================================
  
  const suggestFixes = () => {
    if (!options.includeSuggestions) return [];
    
    const suggestions = [];
    
    // Sugerir mapeamentos para eventos n√£o mapeados
    unmappedEvents.forEach(eventType => {
      const suggestedAction = findSuggestedAction(eventType, unusedActions);
      
      if (suggestedAction) {
        const serviceName = getServiceNameFromEvent(eventType);
        
        suggestions.push({
          type: 'ADD_MAPPING',
          event: eventType,
          action: suggestedAction,
          serviceName,
          confidence: 'medium',
          code: `eventActionBridgeService.registerMapping(
  '${serviceName}',
  ${getEventConstantName(eventType)},
  ${getActionConstantName(suggestedAction)},
  (eventData) => ({
    ...eventData,
    timestamp: eventData.timestamp || Date.now()
  })
);`
        });
      }
    });
    
    // Sugerir consolida√ß√£o para eventos com m√∫ltiplas a√ß√µes
    eventsWithMultipleActions.forEach(([event, actions]) => {
      suggestions.push({
        type: 'CONSOLIDATE_ACTIONS',
        event,
        actions,
        confidence: 'high',
        description: `O evento ${event} dispara m√∫ltiplas a√ß√µes (${actions.join(', ')}). Considere consolidar em uma √∫nica a√ß√£o composta ou usar um middleware.`,
        code: `// Exemplo de consolida√ß√£o via middleware
const eventMiddleware = store => next => action => {
  // Para a√ß√µes consolidadas
  if (action.type === '${actions[0]}' && action.meta?.source === '${event}') {
    // Despachar a√ß√µes secund√°rias
    ${actions.slice(1).map(a => `store.dispatch({ type: '${a}', payload: action.payload });`).join('\n    ')}
  }
  return next(action);
}`
      });
    });
    
    // Sugerir mapeamentos padr√£o para a√ß√µes comuns
    unusedActions.forEach(action => {
      // Tentar inferir evento correspondente com base em conven√ß√µes comuns
      const actionParts = action.split('/');
      if (actionParts.length !== 2) return;
      
      const [module, actionType] = actionParts;
      
      // Mapear padr√µes comuns
      const commonPatterns = {
        'FETCH_SUCCESS': '_FETCHED',
        'UPDATE_SUCCESS': '_UPDATED',
        'DELETE_SUCCESS': '_DELETED',
        'CREATE_SUCCESS': '_CREATED'
      };
      
      Object.entries(commonPatterns).forEach(([actionPattern, eventSuffix]) => {
        if (actionType.includes(actionPattern)) {
          const baseEventName = module.toUpperCase();
          const potentialEvent = `${baseEventName}${eventSuffix}`;
          
          if (unmappedEvents.includes(potentialEvent)) {
            suggestions.push({
              type: 'ADD_MAPPING_CONVENTION',
              event: potentialEvent,
              action,
              serviceName: module,
              confidence: 'medium',
              description: `Baseado em conven√ß√µes, ${potentialEvent} deveria mapear para ${action}`,
              code: `eventActionBridgeService.registerMapping(
  '${module}',
  ${getEventConstantName(potentialEvent)},
  ${getActionConstantName(action)},
  (eventData) => ({
    ...eventData,
    timestamp: eventData.timestamp || Date.now()
  })
);`
            });
          }
        }
      });
    });
    
    return suggestions;
  };
  
  // =========================================================================
  // An√°lise de Impacto
  // =========================================================================
  
  const analyzeImpact = () => {
    if (!options.includeImpactAnalysis) return null;
    
    // Determinar a severidade de um problema de mapeamento
    const determineSeverity = (eventType, issue) => {
      // Crit√©rios para definir severidade
      const criticalEventPrefixes = ['AUTH_', 'USER_', 'INIT_'];
      const isCriticalEvent = criticalEventPrefixes.some(prefix => eventType.startsWith(prefix));
      
      switch (issue) {
        case 'unmapped':
          return isCriticalEvent ? 'high' : 'medium';
        case 'multiAction':
          // M√∫ltiplas a√ß√µes podem ser intencionais, mas merecem revis√£o
          return 'medium';
        case 'invalid':
          // Inv√°lido representa um risco direto
          return 'high';
        default:
          return 'low';
      }
    };
    
    // Identificar componentes e fluxos afetados
    const impactAnalysis = {
      criticalIssues: [],
      affectedModules: new Set(),
      severity: {
        high: 0,
        medium: 0,
        low: 0
      }
    };
    
    // Analisar eventos n√£o mapeados
    unmappedEvents.forEach(event => {
      const severity = determineSeverity(event, 'unmapped');
      impactAnalysis.severity[severity]++;
      
      if (severity === 'high') {
        impactAnalysis.criticalIssues.push({
          type: 'unmapped_event',
          item: event,
          reason: 'Evento cr√≠tico sem mapeamento de a√ß√£o'
        });
      }
      
      // Determinar m√≥dulo afetado
      const moduleName = eventToNamespaceMap[event]?.namespace?.replace('_EVENTS', '') || 'desconhecido';
      impactAnalysis.affectedModules.add(moduleName);
    });
    
    // Analisar a√ß√µes inv√°lidas
    invalidActions.forEach(action => {
      impactAnalysis.severity.high++;
      
      impactAnalysis.criticalIssues.push({
        type: 'invalid_action',
        item: action,
        reason: 'A√ß√£o inv√°lida no mapeamento'
      });
      
      const moduleName = getModuleFromAction(action);
      impactAnalysis.affectedModules.add(moduleName);
    });
    
    // Analisar eventos inv√°lidos
    invalidEvents.forEach(event => {
      impactAnalysis.severity.high++;
      
      impactAnalysis.criticalIssues.push({
        type: 'invalid_event',
        item: event,
        reason: 'Evento inv√°lido no mapeamento'
      });
    });
    
    // Analisar eventos com m√∫ltiplas a√ß√µes
    eventsWithMultipleActions.forEach(([event, actions]) => {
      const severity = determineSeverity(event, 'multiAction');
      impactAnalysis.severity[severity]++;
      
      if (severity === 'high') {
        impactAnalysis.criticalIssues.push({
          type: 'multiple_actions',
          item: event,
          actions,
          reason: 'Evento dispara m√∫ltiplas a√ß√µes, poss√≠vel inconsist√™ncia'
        });
      }
      
      const moduleName = eventToNamespaceMap[event]?.namespace?.replace('_EVENTS', '') || 'desconhecido';
      impactAnalysis.affectedModules.add(moduleName);
    });
    
    // Resumo do impacto
    return {
      ...impactAnalysis,
      totalCriticalIssues: impactAnalysis.criticalIssues.length,
      totalAffectedModules: impactAnalysis.affectedModules.size,
      affectedModules: Array.from(impactAnalysis.affectedModules),
      riskLevel: impactAnalysis.severity.high > 0 
        ? 'alto' 
        : (impactAnalysis.severity.medium > 0 ? 'm√©dio' : 'baixo')
    };
  };
  
  // =========================================================================
  // An√°lise de Padr√µes e Conven√ß√µes
  // =========================================================================
  
  const analyzeNamingConventions = () => {
    const eventPrefixes = {};
    const actionPrefixes = {};
    const serviceToEventMap = {};
    
    // Analisar padr√µes em eventos
    mappedEvents.forEach(eventType => {
      const parts = eventType.split('_');
      const prefix = parts[0];
      const verb = parts.length > 1 ? parts[1] : '';
      
      eventPrefixes[prefix] = (eventPrefixes[prefix] || 0) + 1;
      
      // Mapear servi√ßo para evento
      const mapping = Array.from(eventActionBridgeService.mappings.values())
        .find(m => m.eventType === eventType);
      
      if (mapping) {
        if (!serviceToEventMap[mapping.serviceName]) {
          serviceToEventMap[mapping.serviceName] = new Set();
        }
        serviceToEventMap[mapping.serviceName].add(eventType);
      }
    });
    
    // Analisar padr√µes em a√ß√µes
    mappedActions.forEach(actionType => {
      const parts = actionType.split('/');
      if (parts.length !== 2) return;
      
      const [module, action] = parts;
      actionPrefixes[module] = (actionPrefixes[module] || 0) + 1;
      
      const actionVerbs = action.split('_');
      if (actionVerbs.length > 0) {
        const verb = actionVerbs[0];
        actionPrefixes[verb] = (actionPrefixes[verb] || 0) + 1;
      }
    });
    
    // Analisar consist√™ncia
    const consistencyReport = {
      eventPrefixConsistency: Object.keys(eventPrefixes).length <= 10,
      actionPrefixConsistency: Object.keys(actionPrefixes).length <= 15,
      serviceEventConsistency: Object.values(serviceToEventMap).every(events => 
        events.size > 0 && [...events].every(event => event.startsWith(events.values().next().value.split('_')[0]))
      ),
      commonEventPrefixes: Object.entries(eventPrefixes)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([prefix, count]) => `${prefix} (${count})`),
      commonActionModules: Object.entries(actionPrefixes)
        .filter(([key]) => key.length > 2 && !key.includes('_'))
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([prefix, count]) => `${prefix} (${count})`),
      recommendations: []
    };
    
    // Gerar recomenda√ß√µes
    if (!consistencyReport.eventPrefixConsistency) {
      consistencyReport.recommendations.push(
        'Muitos prefixos diferentes em eventos. Considere padronizar os prefixos de eventos para melhor consist√™ncia.'
      );
    }
    
    if (!consistencyReport.serviceEventConsistency) {
      consistencyReport.recommendations.push(
        'Alguns servi√ßos emitem eventos com prefixos inconsistentes. Cada servi√ßo deve usar um prefixo consistente para seus eventos.'
      );
    }
    
    // Analisar conven√ß√µes espec√≠ficas para mapeamentos
    const conventionAnalysis = {
      hasConsistentNaming: true,
      details: []
    };
    
    // Verificar conven√ß√µes de eventos ‚Üí a√ß√µes
    eventActionBridgeService.mappings.forEach(mapping => {
      const eventParts = mapping.eventType.split('_');
      const actionParts = mapping.actionType.split('/')[1]?.split('_') || [];
      
      // Conven√ß√µes comuns
      const conventions = [
        { 
          pattern: eventParts.includes('CREATED'), 
          expected: actionParts.includes('CREATE_SUCCESS') || actionParts.includes('ADD_SUCCESS'),
          message: `Evento ${mapping.eventType} ‚Üí a√ß√£o ${mapping.actionType}: eventos CREATED tipicamente mapeiam para a√ß√µes CREATE_SUCCESS`
        },
        { 
          pattern: eventParts.includes('UPDATED'), 
          expected: actionParts.includes('UPDATE_SUCCESS'),
          message: `Evento ${mapping.eventType} ‚Üí a√ß√£o ${mapping.actionType}: eventos UPDATED tipicamente mapeiam para a√ß√µes UPDATE_SUCCESS`
        },
        { 
          pattern: eventParts.includes('DELETED'), 
          expected: actionParts.includes('DELETE_SUCCESS') || actionParts.includes('REMOVE_SUCCESS'),
          message: `Evento ${mapping.eventType} ‚Üí a√ß√£o ${mapping.actionType}: eventos DELETED tipicamente mapeiam para a√ß√µes DELETE_SUCCESS`
        },
        { 
          pattern: eventParts.includes('FETCHED'), 
          expected: actionParts.includes('FETCH_SUCCESS') || actionParts.includes('LOAD_SUCCESS'),
          message: `Evento ${mapping.eventType} ‚Üí a√ß√£o ${mapping.actionType}: eventos FETCHED tipicamente mapeiam para a√ß√µes FETCH_SUCCESS`
        }
      ];
      
      conventions.forEach(convention => {
        if (convention.pattern && !convention.expected) {
          conventionAnalysis.hasConsistentNaming = false;
          conventionAnalysis.details.push(convention.message);
        }
      });
    });
    
    if (!conventionAnalysis.hasConsistentNaming) {
      consistencyReport.recommendations.push(
        'Existem inconsist√™ncias nas conven√ß√µes de nomea√ß√£o entre eventos e a√ß√µes. Considere padronizar.'
      );
      
      // Adicionar detalhes
      conventionAnalysis.details.forEach(detail => {
        consistencyReport.recommendations.push(`  - ${detail}`);
      });
    }
    
    return consistencyReport;
  };
  
  // =========================================================================
  // Visualiza√ß√£o do Fluxo
  // =========================================================================
  
  const visualizeEventActionFlow = () => {
    const nodes = [];
    const edges = [];
    
    // Criar n√≥s para eventos e a√ß√µes
    eventActionBridgeService.mappings.forEach(mapping => {
      const eventNode = {
        id: `event:${mapping.eventType}`,
        label: mapping.eventType,
        type: 'event',
        group: getServiceNameFromEvent(mapping.eventType)
      };
      
      const actionNode = {
        id: `action:${mapping.actionType}`,
        label: mapping.actionType,
        type: 'action',
        group: getModuleFromAction(mapping.actionType)
      };
      
      // Adicionar apenas n√≥s √∫nicos
      if (!nodes.some(n => n.id === eventNode.id)) {
        nodes.push(eventNode);
      }
      
      if (!nodes.some(n => n.id === actionNode.id)) {
        nodes.push(actionNode);
      }
      
      // Adicionar aresta
      edges.push({
        from: eventNode.id,
        to: actionNode.id,
        service: mapping.serviceName
      });
    });
    
 
    return {
      nodes,
      edges
    };
  };
  
  const flow = visualizeEventActionFlow();

  // =========================================================================
  // Sa√≠da para Console (Visualiza√ß√£o para Desenvolvimento)
  // =========================================================================
  
  if (options.verbose) {
    // Formata√ß√£o melhorada para console
    const printResults = () => {
      const printFormatted = (title, items, isError = false) => {
        console.log(`${isError ? '‚ùå' : '‚úÖ'} ${title}`);
        if (items.length === 0) {
          console.log(`  Nenhum item encontrado.`);
        } else {
          items.forEach(item => console.log(`  - ${item}`));
        }
      };
      
      console.group('üìä Estat√≠sticas');
      console.log(`Total de Eventos Definidos: ${allEventTypes.length}`);
      console.log(`Total de A√ß√µes Definidas: ${allActionTypes.length}`);
      console.log(`Eventos Mapeados: ${mappedEvents.length} (${((mappedEvents.length / allEventTypes.length) * 100).toFixed(1)}%)`);
      console.log(`A√ß√µes Utilizadas: ${mappedActions.length} (${((mappedActions.length / allActionTypes.length) * 100).toFixed(1)}%)`);
      console.log(`Total de Mapeamentos: ${eventActionBridgeService.mappings.size}`);
      console.groupEnd();
      
      console.group('‚ö†Ô∏è Problemas Encontrados');
      printFormatted(`Eventos n√£o mapeados (${unmappedEvents.length})`, unmappedEvents, true);
      printFormatted(`A√ß√µes n√£o utilizadas (${unusedActions.length})`, unusedActions, true);
      
      if (invalidEvents.length) {
        printFormatted(`Eventos inv√°lidos (${invalidEvents.length})`, invalidEvents, true);
      }
      
      if (invalidActions.length) {
        printFormatted(`A√ß√µes inv√°lidas (${invalidActions.length})`, invalidActions, true);
      }
      
      if (eventsWithMultipleActions.length) {
        console.log(`‚ö†Ô∏è Eventos com m√∫ltiplas a√ß√µes (${eventsWithMultipleActions.length})`);
        eventsWithMultipleActions.forEach(([event, actions]) => {
          console.log(`  - ${event} ‚Üí ${actions.join(', ')}`);
        });
      }
      
      if (actionsWithMultipleEvents.length) {
        console.log(`‚ö†Ô∏è A√ß√µes disparadas por m√∫ltiplos eventos (${actionsWithMultipleEvents.length})`);
        actionsWithMultipleEvents.forEach(([action, events]) => {
          console.log(`  - ${action} ‚Üê ${events.join(', ')}`);
        });
      }
      console.groupEnd();
      
      // Exibir resultados agrupados por m√≥dulo
      console.group('üì¶ Resultados Agrupados por M√≥dulo');
      console.log('Eventos N√£o Mapeados:');
      Object.entries(groupedUnmapped).forEach(([module, items]) => {
        console.log(`  ${module}: ${items.length} eventos`);
      });
      
      console.log('\nA√ß√µes N√£o Utilizadas:');
      Object.entries(groupedUnused).forEach(([module, items]) => {
        console.log(`  ${module}: ${items.length} a√ß√µes`);
      });
      console.groupEnd();
    };
    
    printResults();
    
    // =========================================================================
    // Sugest√µes Autom√°ticas
    // =========================================================================
    
    if (options.includeSuggestions) {
      const suggestions = suggestFixes();
      
      console.group('üí° Sugest√µes Autom√°ticas');
      if (suggestions.length === 0) {
        console.log('Nenhuma sugest√£o autom√°tica gerada.');
      } else {
        console.log(`Total de Sugest√µes: ${suggestions.length}`);
        
        suggestions.forEach((suggestion, index) => {
          console.group(`Sugest√£o #${index + 1} (${suggestion.type})`);
          console.log(`Evento: ${suggestion.event}`);
          
          if (suggestion.action) {
            console.log(`A√ß√£o: ${suggestion.action}`);
          }
          
          if (suggestion.serviceName) {
            console.log(`Servi√ßo: ${suggestion.serviceName}`);
          }
          
          console.log(`Confian√ßa: ${suggestion.confidence}`);
          
          if (suggestion.description) {
            console.log(`Descri√ß√£o: ${suggestion.description}`);
          }
          
          console.log('C√≥digo:');
          console.log(suggestion.code);
          console.groupEnd();
        });
      }
      console.groupEnd();
    }
    
    // =========================================================================
    // An√°lise de Impacto
    // =========================================================================
    
    if (options.includeImpactAnalysis) {
      const impact = analyzeImpact();
      
      console.group('üìà An√°lise de Impacto');
      console.log(`N√≠vel de Risco: ${impact.riskLevel}`);
      console.log(`Problemas Cr√≠ticos: ${impact.totalCriticalIssues}`);
      console.log(`M√≥dulos Afetados: ${impact.totalAffectedModules}`);
      console.log(`Severidade:`);
      console.log(`  - Alta: ${impact.severity.high}`);
      console.log(`  - M√©dia: ${impact.severity.medium}`);
      console.log(`  - Baixa: ${impact.severity.low}`);
      
      if (impact.criticalIssues.length > 0) {
        console.group('üö® Problemas Cr√≠ticos');
        impact.criticalIssues.forEach(issue => {
          console.log(`[${issue.type.toUpperCase()}] ${issue.item}`);
          console.log(`  Motivo: ${issue.reason}`);
          if (issue.actions) {
            console.log(`  A√ß√µes: ${issue.actions.join(', ')}`);
          }
        });
        console.groupEnd();
      }
      
      console.log('M√≥dulos Afetados:');
      impact.affectedModules.forEach(module => {
        console.log(`  - ${module}`);
      });
      console.groupEnd();
    }
    
    // =========================================================================
    // An√°lise de Padr√µes e Conven√ß√µes
    // =========================================================================
    
    const conventions = analyzeNamingConventions();
    
    console.group('üî§ An√°lise de Padr√µes e Conven√ß√µes');
    console.log('Consist√™ncia de Prefixos de Eventos:', conventions.eventPrefixConsistency ? '‚úÖ Boa' : '‚ùå Precisa melhorar');
    console.log('Consist√™ncia de M√≥dulos de A√ß√µes:', conventions.actionPrefixConsistency ? '‚úÖ Boa' : '‚ùå Precisa melhorar');
    console.log('Consist√™ncia Servi√ßo-Evento:', conventions.serviceEventConsistency ? '‚úÖ Boa' : '‚ùå Precisa melhorar');
    
    console.log('\nPrefixos de Eventos Mais Comuns:');
    conventions.commonEventPrefixes.forEach(prefix => console.log(`  - ${prefix}`));
    
    console.log('\nM√≥dulos de A√ß√µes Mais Comuns:');
    conventions.commonActionModules.forEach(module => console.log(`  - ${module}`));
    
    if (conventions.recommendations.length > 0) {
      console.group('\nüìå Recomenda√ß√µes');
      conventions.recommendations.forEach(rec => console.log(`- ${rec}`));
      console.groupEnd();
    }
    console.groupEnd();
    
    // =========================================================================
    // Visualiza√ß√£o do Fluxo (simulada)
    // =========================================================================
    
    console.group('üîÑ Visualiza√ß√£o do Fluxo Evento-A√ß√£o (Componente React)');
    console.log('Dados para o componente FlowDiagram:');
    console.log('Nodes:', flow.nodes);
    console.log('Edges:', flow.edges);
    console.log('Para renderizar, use o componente FlowDiagram com esses dados.');
    console.log('<FlowDiagram nodes={flow.nodes} edges={flow.edges} />');
    console.groupEnd();
  }
  
  // =========================================================================
  // Exporta√ß√£o de Relat√≥rios
  // =========================================================================
  
  const generateReport = () => {
    return {
      summary: {
        totalEvents: allEventTypes.length,
        totalActions: allActionTypes.length,
        mappedEvents: mappedEvents.length,
        mappedActions: mappedActions.length,
        mappingCoverage: {
          events: ((mappedEvents.length / allEventTypes.length) * 100).toFixed(1) + '%',
          actions: ((mappedActions.length / allActionTypes.length) * 100).toFixed(1) + '%'
        },
        totalMappings: eventActionBridgeService.mappings.size
      },
      issues: {
        unmappedEvents,
        unusedActions,
        invalidEvents,
        invalidActions,
        eventsWithMultipleActions,
        actionsWithMultipleEvents
      },
      groupedResults: {
        unmappedByModule: groupedUnmapped,
        unusedByModule: groupedUnused,
        mappedEventsByModule: groupedMappedEvents,
        mappedActionsByModule: groupedMappedActions
      },
      suggestions: options.includeSuggestions ? suggestFixes() : [],
      impactAnalysis: options.includeImpactAnalysis ? analyzeImpact() : null,
      namingConventions: analyzeNamingConventions(),
      flowVisualization: visualizeEventActionFlow(),
      timestamp: new Date().toISOString()
    };
  };
  
  // =========================================================================
  // Fun√ß√£o Utilit√°ria para Documenta√ß√£o
  // =========================================================================
  
  const generateDocumentation = () => {
    const doc = {
      introduction: "Documenta√ß√£o dos Mapeamentos Evento-A√ß√£o",
      overview: "Este documento descreve todos os mapeamentos entre eventos e a√ß√µes no sistema.",
      mappings: []
    };
    
    eventActionBridgeService.mappings.forEach(mapping => {
      doc.mappings.push({
        service: mapping.serviceName,
        event: mapping.eventType,
        action: mapping.actionType,
        description: `Quando ${mapping.eventType} √© emitido, ${mapping.actionType} √© despachada`,
        eventOrigin: eventToNamespaceMap[mapping.eventType]?.namespace || 'desconhecido',
        actionModule: getModuleFromAction(mapping.actionType)
      });
    });
    
    return doc;
  };
  
  // =========================================================================
  // Finaliza√ß√£o
  // =========================================================================
  
  console.groupEnd();
  
  return {
    getReport: generateReport,
    getDocumentation: generateDocumentation,
    unmappedEvents,
    unusedActions,
    invalidEvents,
    invalidActions,
    eventsWithMultipleActions,
    actionsWithMultipleEvents,
    suggestions: options.includeSuggestions ? suggestFixes() : [],
    impact: options.includeImpactAnalysis ? analyzeImpact() : null,
    conventions: analyzeNamingConventions(),
    flow: flow,
  };
};

// =========================================================================
// Comandos para Corre√ß√£o Autom√°tica
// =========================================================================

export const applyAutoFixes = (suggestions) => {
  const eventActionBridgeService = serviceLocator.get('eventActionBridge')

  const results = {
    applied: 0,
    skipped: 0,
    errors: 0,
    details: []
  };
  
  suggestions.forEach(suggestion => {
    try {
      if (suggestion.type === 'ADD_MAPPING' || suggestion.type === 'ADD_MAPPING_CONVENTION') {
        // Extrair par√¢metros do c√≥digo sugerido
        const match = suggestion.code.match(/registerMapping\(([^)]+)\)/);
        if (match) {
          const args = match[1].split(',').map(arg => arg.trim().replace(/^['"]|['"]$/g, ''));
          
          // Registrar o mapeamento
          eventActionBridgeService.registerMapping(
            args[0], // serviceName
            eval(args[1]), // eventType (avaliado para resolver constantes)
            eval(args[2]), // actionType
            eval(`(${args[3]})`) // transformer
          );
          
          results.applied++;
          results.details.push({
            type: suggestion.type,
            event: suggestion.event,
            action: suggestion.action,
            status: 'success'
          });
        } else {
          results.skipped++;
          results.details.push({
            type: suggestion.type,
            event: suggestion.event,
            action: suggestion.action,
            status: 'skipped',
            reason: 'N√£o foi poss√≠vel extrair par√¢metros do c√≥digo'
          });
        }
      } else {
        results.skipped++;
        results.details.push({
          type: suggestion.type,
          status: 'skipped',
          reason: 'Tipo de sugest√£o n√£o implementado para corre√ß√£o autom√°tica'
        });
      }
    } catch (error) {
      results.errors++;
      results.details.push({
        type: suggestion.type,
        event: suggestion.event,
        action: suggestion.action,
        status: 'error',
        error: error.message
      });
    }
  });
  
  return results;
};

// =========================================================================
// Monitoramento em Tempo Real
// =========================================================================

export const setupRealTimeMonitoring = (callback) => {
  const eventActionBridgeService = serviceLocator.get('eventActionBridge')

  const originalRegister = eventActionBridgeService.registerMapping;
  
  // Decorar o m√©todo registerMapping para capturar novos mapeamentos
  eventActionBridgeService.registerMapping = function(...args) {
    const result = originalRegister.apply(this, args);
    
    // Notificar o callback sobre o novo mapeamento
    if (callback) {
      callback({
        type: 'MAPPING_ADDED',
        serviceName: args[0],
        eventType: args[1],
        actionType: args[2],
        timestamp: new Date().toISOString()
      });
    }
    
    return result;
  };
  
  // Retornar fun√ß√£o para limpeza
  return () => {
    eventActionBridgeService.registerMapping = originalRegister;
  };
};

// =========================================================================
// Integra√ß√£o com o Sistema de Testes
// =========================================================================

export const generateTestCases = () => {
  const eventActionBridgeService = serviceLocator.get('eventActionBridge')

  const testCases = [];
  
  // Gerar testes para cada mapeamento
  eventActionBridgeService.mappings.forEach(mapping => {
    testCases.push({
      description: `Deve despachar ${mapping.actionType} quando ${mapping.eventType} √© emitido`,
      code: `it('${mapping.actionType} should be dispatched when ${mapping.eventType} is emitted', () => {
  const mockDispatch = jest.fn();
  const eventData = { /* dados de exemplo */ };
  
  // Simular emiss√£o do evento
  eventActionBridgeService.emit('${mapping.eventType}', eventData);
  
  // Verificar se a a√ß√£o foi despachada
  expect(mockDispatch).toHaveBeenCalledWith({
    type: '${mapping.actionType}',
    payload: expect.objectContaining(eventData)
  });
});`
    });
  });
  
  // Gerar testes para eventos n√£o mapeados
  const unmappedEvents = Object.values({
    ...AUTH_EVENTS,
    ...CONNECTION_EVENTS,
    ...MESSAGE_EVENTS,
    ...INVITATION_EVENTS,
    ...NOTIFICATION_EVENTS,
    ...INTERESTS_EVENTS,
    ...USER_EVENTS,
    ...CAIXINHA_EVENTS,
    ...USER_PREFS_EVENTS
  }).filter(e => !Array.from(eventActionBridgeService.mappings.values()).some(m => m.eventType === e));
  
  unmappedEvents.forEach(event => {
    testCases.push({
      description: `Deve ter um mapeamento para o evento ${event}`,
      code: `it('should have a mapping for ${event} event', () => {
  const mapping = Array.from(eventActionBridgeService.mappings.values())
    .find(m => m.eventType === '${event}');
    
  expect(mapping).toBeDefined();
});`
    });
  });
  
  return testCases;
};

// =========================================================================
// Rastreamento Hist√≥rico
// =========================================================================

const mappingHistory = [];

export const trackMappingChanges = () => {
  const eventActionBridgeService = serviceLocator.get('eventActionBridge')

  const originalRegister = eventActionBridgeService.registerMapping;
  
  eventActionBridgeService.registerMapping = function(...args) {
    const result = originalRegister.apply(this, args);
    
    // Registrar no hist√≥rico
    mappingHistory.push({
      type: 'REGISTER',
      serviceName: args[0],
      eventType: args[1],
      actionType: args[2],
      timestamp: new Date().toISOString(),
      stackTrace: new Error().stack.split('\n').slice(2).join('\n')
    });
    
    return result;
  };
  
  const originalUnregister = eventActionBridgeService.unregisterMapping;
  
  eventActionBridgeService.unregisterMapping = function(...args) {
    const result = originalUnregister.apply(this, args);
    
    // Registrar no hist√≥rico
    mappingHistory.push({
      type: 'UNREGISTER',
      serviceName: args[0],
      eventType: args[1],
      timestamp: new Date().toISOString(),
      stackTrace: new Error().stack.split('\n').slice(2).join('\n')
    });
    
    return result;
  };
  
  // Retornar fun√ß√£o para limpeza
  return () => {
    eventActionBridgeService.registerMapping = originalRegister;
    eventActionBridgeService.unregisterMapping = originalUnregister;
  };
};

export const getMappingHistory = (options = {}) => {

  const { limit = 50, filter } = options;
  let results = [...mappingHistory];
  
  if (filter) {
    results = results.filter(entry => {
      return Object.entries(filter).every(([key, value]) => {
        return entry[key] === value;
      });
    });
  }
  
  return results.slice(0, limit);
};